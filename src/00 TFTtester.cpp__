/**
 * üìü TFT + Touchscreen + Backlight + Calibration Example
 * by Daniel, HB9IIU
 *
 * ‚û§ Tests 4-Inch TFT display with ESP32 and XPT2046-style touchscreen
 * ‚û§ Supports backlight control (active HIGH) using -D TFT_BLP=4
 * ‚û§ Performs touchscreen calibration and stores data in Preferences
 * ‚û§ Coordinates are shown at the top-center, red dots at touch points
 * ‚û§ Calibration is skipped on boot if valid data already exists
 *
 * üìÅ See platformio.ini for pin assignments
 * üìÇ Refer to 'doc' folder for connection diagram
 */

#include <TFT_eSPI.h> // Bodmer's TFT display library
#include <SPI.h>
#include <Preferences.h> // For saving calibration data

Preferences preferences;
TFT_eSPI tft = TFT_eSPI(); // TFT instance

// Prototypes
void checkAndApplyTFTCalibrationData(bool recalibrate);
void calibrateTFTscreen();

void setup()
{
    // --- Backlight control sequence ---
    pinMode(TFT_BLP, OUTPUT);
    digitalWrite(TFT_BLP, HIGH); // Leave ON

    // --- TFT setup ---
    tft.init();
    tft.setRotation(3);
    tft.fillScreen(TFT_BLACK);

    // --- Touch calibration (auto unless forced) ---
    checkAndApplyTFTCalibrationData(true); // set to true to force recalibration

    // --- Welcome screen ---
    tft.setTextDatum(MC_DATUM);
    tft.setTextSize(1);
    tft.setTextColor(TFT_GREEN, TFT_BLACK);
    tft.drawString("HELLO WORLD !!!", tft.width() / 2, tft.height() / 2);

    // --- Status message below ---
    tft.setTextSize(1);
    tft.setFreeFont(NULL); // Use built-in font (not a .vlw font)

    tft.setTextColor(TFT_LIGHTGREY, TFT_BLACK);
    tft.drawString("Touch coordinates may be offset", tft.width() / 2, (tft.height() / 2) + 20);
    tft.drawString("Screen is now calibrated", tft.width() / 2, (tft.height() / 2) + 32);

    Serial.begin(115200);
    Serial.println("üìü TFT + Touch test ready");
}

void loop()
{
    uint16_t x, y;
    if (tft.getTouch(&x, &y))
    {
        // Draw red touch dot
        tft.fillCircle(x, y, 4, TFT_RED);

        // Show coordinates at top center
        tft.setTextDatum(MC_DATUM);
        tft.setTextColor(TFT_YELLOW, TFT_BLACK);
        tft.setTextSize(2);
        char buf[40];
        sprintf(buf, "x=%d  y=%d", x, y);
        tft.fillRect(0, 0, tft.width(), 30, TFT_BLACK);
        tft.drawString(buf, tft.width() / 2, 10);

        // Serial debug
        Serial.printf("üñ±Ô∏è  Touch at: x=%d y=%d\n", x, y);
    }

    delay(50);
}

void checkAndApplyTFTCalibrationData(bool recalibrate)
{
    if (recalibrate)
    {
        calibrateTFTscreen();
        return;
    }

    uint16_t calibrationData[5];
    preferences.begin("TFT", true);
    bool dataValid = true;

    for (int i = 0; i < 5; i++)
    {
        calibrationData[i] = preferences.getUInt(("calib" + String(i)).c_str(), 0xFFFF);
        if (calibrationData[i] == 0xFFFF)
        {
            dataValid = false;
        }
    }
    preferences.end();

    if (dataValid)
    {
        tft.setTouch(calibrationData);
        Serial.println("Calibration data applied.");
    }
    else
    {
        Serial.println("Invalid calibration data. Recalibrating...");
        calibrateTFTscreen();
    }
}

void calibrateTFTscreen()
{
    uint16_t calibrationData[5];

    // Display recalibration message
    tft.fillScreen(TFT_BLACK);             // Clear screen
    tft.setTextColor(TFT_BLACK, TFT_GOLD); // Set text color (black on gold)
    tft.setFreeFont(&FreeSansBold9pt7b);   // Use custom free font
    tft.setTextSize(1);
    tft.setCursor(5, 22);
    tft.fillRect(0, 0, tft.width(), 30, TFT_GOLD);
    tft.print("TFT TOUCHSCREEN CALIBRATION");
    tft.setTextColor(TFT_WHITE, TFT_BLACK);

    tft.setFreeFont(&FreeSans9pt7b);

    String instructions[] = {
        "Initial touchscreen calibration",
        "Procedure will only be required once",
        "On the next screen you will see arrows",
        "appearing at each corner",
        "Just tap them until completion.",
        "",
        "Tap anywhere on the screen to begin"};

    int16_t yPos = 70;

    for (String line : instructions)
    {
        int16_t xPos = (tft.width() - tft.textWidth(line)) / 2;
        tft.setCursor(xPos, yPos);
        tft.print(line);
        yPos += tft.fontHeight();
    }

    tft.setTextColor(TFT_GREEN, TFT_BLACK);
    tft.setCursor((tft.width() - tft.textWidth(instructions[6])) / 2, yPos - tft.fontHeight());
    tft.print(instructions[6]);

    while (true)
    {
        uint16_t x, y;
        if (tft.getTouch(&x, &y))
        {
            break;
        }
    }

    tft.fillScreen(TFT_BLACK);

    tft.calibrateTouch(calibrationData, TFT_GREEN, TFT_BLACK, 12);

    preferences.begin("TFT", false);
    for (int i = 0; i < 5; i++)
    {
        preferences.putUInt(("calib" + String(i)).c_str(), calibrationData[i]);
    }
    preferences.end();

    // Test calibration with dynamic feedback
    tft.fillScreen(TFT_BLACK);
    uint16_t x, y;
    int16_t lastX = -1, lastY = -1;
    String lastResult = "";

    tft.setTextColor(TFT_WHITE, TFT_BLACK);
    tft.setTextFont(4);
    String text = "Tap anywhere to test";
    tft.setCursor((tft.width() - tft.textWidth(text)) / 2, 8);
    tft.print(text);

    text = "Click Here to Exit";
    int16_t btn_w = tft.textWidth(text) + 20;
    int16_t btn_h = tft.fontHeight() + 12;
    int16_t btn_x = (tft.width() - btn_w) / 2;
    int16_t btn_y = 200;
    int16_t btn_r = 10;

    tft.fillRoundRect(btn_x, btn_y, btn_w, btn_h, btn_r, TFT_BLUE);
    tft.drawRoundRect(btn_x, btn_y, btn_w, btn_h, btn_r, TFT_WHITE);
    tft.setTextColor(TFT_WHITE, TFT_BLUE);
    tft.setCursor((tft.width() - tft.textWidth(text)) / 2, btn_y + 10);
    tft.print(text);

    while (true)
    {
        if (tft.getTouch(&x, &y))
        {
            String result = "x=" + String(x) + "  y=" + String(y) + "  p=" + String(tft.getTouchRawZ());

            tft.setTextColor(TFT_BLACK, TFT_BLACK);
            tft.setCursor(lastX, lastY);
            tft.print(lastResult);

            int16_t textWidth = tft.textWidth(result);
            int16_t xPos = (tft.width() - textWidth) / 2;
            int16_t yPos = (tft.height() - tft.fontHeight()) / 2;

            tft.setTextColor(TFT_GREEN, TFT_BLACK);
            tft.setCursor(xPos, yPos);
            tft.print(result);

            lastX = xPos;
            lastY = yPos;
            lastResult = result;

            tft.fillCircle(x, y, 2, TFT_RED);

            if (x > btn_x && x < btn_x + btn_w && y > btn_y && y < btn_y + btn_h)
            {
                Serial.println("Exit Touched");
                break;
            }
        }
    }
    tft.setTextSize(1);
    tft.fillScreen(TFT_BLACK);
}
